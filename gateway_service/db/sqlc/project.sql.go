// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: project.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addKBToProject = `-- name: AddKBToProject :exec
INSERT INTO "knowledge_base_project_mapping" (knowledge_base_id, project_id)
VALUES ($1, $2)
`

type AddKBToProjectParams struct {
	KnowledgeBaseID uuid.UUID `json:"knowledge_base_id"`
	ProjectID       uuid.UUID `json:"project_id"`
}

func (q *Queries) AddKBToProject(ctx context.Context, arg AddKBToProjectParams) error {
	_, err := q.db.Exec(ctx, addKBToProject, arg.KnowledgeBaseID, arg.ProjectID)
	return err
}

const addUserToProject = `-- name: AddUserToProject :exec
INSERT INTO "user_project_mapping" (user_id, project_id)
VALUES ($1, $2)
ON CONFLICT (user_id, project_id) DO NOTHING
`

type AddUserToProjectParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProjectID uuid.UUID `json:"project_id"`
}

func (q *Queries) AddUserToProject(ctx context.Context, arg AddUserToProjectParams) error {
	_, err := q.db.Exec(ctx, addUserToProject, arg.UserID, arg.ProjectID)
	return err
}

const countKBsInProject = `-- name: CountKBsInProject :one
SELECT COUNT(*) FROM "knowledge_base_project_mapping" WHERE "project_id" = $1
`

func (q *Queries) CountKBsInProject(ctx context.Context, projectID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countKBsInProject, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO "project" (name, owner_id, description)
VALUES ($1, $2, $3)
RETURNING id, name, owner_id, description, created_at
`

type CreateProjectParams struct {
	Name        string    `json:"name"`
	OwnerID     uuid.UUID `json:"owner_id"`
	Description string    `json:"description"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject, arg.Name, arg.OwnerID, arg.Description)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM "project"
WHERE "id" = $1
  AND NOT EXISTS (
    SELECT 1 FROM "knowledge_base_project_mapping"
    WHERE "project_id" = $1
  )
`

func (q *Queries) DeleteProject(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, name, owner_id, description, created_at FROM "project"
WHERE "id" = $1
`

func (q *Queries) GetProjectByID(ctx context.Context, id uuid.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getProjectWithUsersAndKBs = `-- name: GetProjectWithUsersAndKBs :one
SELECT 
    project.id, project.name, project.owner_id, project.description, project.created_at, 
    COALESCE(
        (SELECT jsonb_agg(user_info) 
         FROM (
             SELECT 
                 "user".id,
                 "user".email,
                 "user".username,
                 "user".role_name,
                 "user".is_active,
                 "user".is_email_verified,
                 "user".avatar,
                 "user".phone,
                 "user".created_at,
                 "user".last_login
             FROM "user"
             LEFT JOIN "user_project_mapping" ON "user"."id" = "user_project_mapping"."user_id"
             WHERE "user_project_mapping"."project_id" = "project"."id"
             GROUP BY "user"."id"
             HAVING "user"."id" IS NOT NULL
         ) AS user_info),
        '[]'
    ) AS users,
    COALESCE(
        (SELECT jsonb_agg(kb_info) 
         FROM (
             SELECT 
                 "kb".id,
                 "kb".name,
                 "kb".owner_id,
                 COUNT(DISTINCT "kb_file_mapping"."kb_file_id") AS kb_file_count,
                 SUM(CASE 
                     WHEN "kb_file_mapping"."is_build_finished" = true 
                        AND "kb_file_mapping"."is_build_failed" = false 
                     THEN 1 
                     ELSE 0 
                 END) AS kb_file_build_finished_count,
                 "kb".created_at,
                 "kb".updated_at
             FROM "knowledge_base" AS "kb"
             LEFT JOIN "knowledge_base_project_mapping" ON "kb"."id" = "knowledge_base_project_mapping"."knowledge_base_id" 
             LEFT JOIN "kb_file_mapping" ON "kb"."id" = "kb_file_mapping"."kb_id"
             WHERE "knowledge_base_project_mapping"."project_id" = "project"."id"
             GROUP BY "kb"."id"
             HAVING "kb"."id" IS NOT NULL
         ) AS kb_info),
        '[]'
    ) AS kbs
FROM "project"
WHERE "project"."id" = $1
`

type GetProjectWithUsersAndKBsRow struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	OwnerID     uuid.UUID   `json:"owner_id"`
	Description string      `json:"description"`
	CreatedAt   time.Time   `json:"created_at"`
	Users       interface{} `json:"users"`
	Kbs         interface{} `json:"kbs"`
}

func (q *Queries) GetProjectWithUsersAndKBs(ctx context.Context, id uuid.UUID) (GetProjectWithUsersAndKBsRow, error) {
	row := q.db.QueryRow(ctx, getProjectWithUsersAndKBs, id)
	var i GetProjectWithUsersAndKBsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Description,
		&i.CreatedAt,
		&i.Users,
		&i.Kbs,
	)
	return i, err
}

const getUserProjectsWithKBs = `-- name: GetUserProjectsWithKBs :many
SELECT 
    project.id, project.name, project.owner_id, project.description, project.created_at, 
    COALESCE(
        (SELECT jsonb_agg(kb_info) 
         FROM (
             SELECT 
                 kb.id,
                 kb.name,
                 kb.owner_id,
                 kb.created_at,
                 kb.updated_at,
                 COUNT(DISTINCT kb_file_mapping.kb_file_id) AS kb_file_count,
                 SUM(CASE 
                     WHEN kb_file_mapping.is_build_finished = true 
                        AND kb_file_mapping.is_build_failed = false 
                     THEN 1 
                     ELSE 0 
                 END) AS kb_file_build_finished_count
             FROM "knowledge_base" AS "kb"
             LEFT JOIN "knowledge_base_project_mapping" 
                 ON "kb"."id" = "knowledge_base_project_mapping"."knowledge_base_id"
             LEFT JOIN "kb_file_mapping" 
                 ON "kb"."id" = "kb_file_mapping"."kb_id"
             WHERE "knowledge_base_project_mapping"."project_id" = "project"."id"
             GROUP BY kb.id
             HAVING kb.id IS NOT NULL
         ) AS kb_info),
        '[]'
    ) AS kbs,
    COUNT("user_project_mapping"."user_id") AS num_users
FROM "project"
LEFT JOIN "user_project_mapping" 
    ON "project"."id" = "user_project_mapping"."project_id"
WHERE "user_project_mapping"."user_id" = $1
GROUP BY "project"."id"
`

type GetUserProjectsWithKBsRow struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	OwnerID     uuid.UUID   `json:"owner_id"`
	Description string      `json:"description"`
	CreatedAt   time.Time   `json:"created_at"`
	Kbs         interface{} `json:"kbs"`
	NumUsers    int64       `json:"num_users"`
}

func (q *Queries) GetUserProjectsWithKBs(ctx context.Context, userID uuid.UUID) ([]GetUserProjectsWithKBsRow, error) {
	rows, err := q.db.Query(ctx, getUserProjectsWithKBs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserProjectsWithKBsRow{}
	for rows.Next() {
		var i GetUserProjectsWithKBsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.Description,
			&i.CreatedAt,
			&i.Kbs,
			&i.NumUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isKbAccessibleByUserID = `-- name: IsKbAccessibleByUserID :one
SELECT EXISTS (
    SELECT 1 
    FROM (
        -- Check if user has access through project mapping
        SELECT 1 
        FROM "user_project_mapping" upm
        JOIN "knowledge_base_project_mapping" kbpm 
            ON upm.project_id = kbpm.project_id
        WHERE upm.user_id = $1 
            AND kbpm.knowledge_base_id = $2

        UNION

        -- Check if user is the owner of the knowledge base
        SELECT 1
        FROM "knowledge_base"  
        WHERE "knowledge_base"."id" = $2 AND "knowledge_base"."owner_id" = $1

    ) access_check
) AS is_accessible
`

type IsKbAccessibleByUserIDParams struct {
	UserID          uuid.UUID `json:"user_id"`
	KnowledgeBaseID uuid.UUID `json:"knowledge_base_id"`
}

func (q *Queries) IsKbAccessibleByUserID(ctx context.Context, arg IsKbAccessibleByUserIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, isKbAccessibleByUserID, arg.UserID, arg.KnowledgeBaseID)
	var is_accessible bool
	err := row.Scan(&is_accessible)
	return is_accessible, err
}

const isUserInProject = `-- name: IsUserInProject :one
SELECT EXISTS (SELECT 1 FROM "user_project_mapping" WHERE "user_id" = $1 AND "project_id" = $2)
`

type IsUserInProjectParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProjectID uuid.UUID `json:"project_id"`
}

func (q *Queries) IsUserInProject(ctx context.Context, arg IsUserInProjectParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInProject, arg.UserID, arg.ProjectID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listJoinedProjects = `-- name: ListJoinedProjects :many
SELECT id, name, owner_id, description, created_at FROM "project"
WHERE "id" IN (SELECT "project_id" FROM "user_project_mapping" WHERE "user_id" = $1)
`

func (q *Queries) ListJoinedProjects(ctx context.Context, userID uuid.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, listJoinedProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT 
    project.id, project.name, project.owner_id, project.description, project.created_at,
    EXISTS (
        SELECT 1 
        FROM "user_project_mapping" 
        WHERE "user_project_mapping"."project_id" = "project"."id" 
        AND "user_project_mapping"."user_id" = $1
    ) AS is_member,
    "project"."owner_id" = $1 AS is_owner
FROM "project"
`

type ListProjectsRow struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	OwnerID     uuid.UUID `json:"owner_id"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"created_at"`
	IsMember    bool      `json:"is_member"`
	IsOwner     bool      `json:"is_owner"`
}

func (q *Queries) ListProjects(ctx context.Context, userID uuid.UUID) ([]ListProjectsRow, error) {
	rows, err := q.db.Query(ctx, listProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectsRow{}
	for rows.Next() {
		var i ListProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.Description,
			&i.CreatedAt,
			&i.IsMember,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithProjects = `-- name: ListUsersWithProjects :many
SELECT  
    "user".id, "user".email, "user".username, "user".hashed_password, "user".is_active, "user".is_email_verified, "user".last_login, "user".password_changed_at, "user".role_name, "user".avatar, "user".phone, "user".created_at, "user".deleted_at,
    COALESCE(
        (SELECT jsonb_agg(project_info) 
         FROM (
             SELECT 
                 "project".id,
                 "project".name,
                 "project".owner_id,
                 "project".description,
                 "project".created_at
             FROM "project"
             LEFT JOIN "user_project_mapping" ON "project"."id" = "user_project_mapping"."project_id"
             WHERE "user_project_mapping"."user_id" = "user"."id"
         ) AS project_info),
        '[]'
    ) AS projects
FROM "user" 
GROUP BY "user"."id"
ORDER BY "user"."id"
`

type ListUsersWithProjectsRow struct {
	ID                uuid.UUID   `json:"id"`
	Email             string      `json:"email"`
	Username          string      `json:"username"`
	HashedPassword    string      `json:"hashed_password"`
	IsActive          bool        `json:"is_active"`
	IsEmailVerified   bool        `json:"is_email_verified"`
	LastLogin         time.Time   `json:"last_login"`
	PasswordChangedAt time.Time   `json:"password_changed_at"`
	RoleName          string      `json:"role_name"`
	Avatar            string      `json:"avatar"`
	Phone             pgtype.Text `json:"phone"`
	CreatedAt         time.Time   `json:"created_at"`
	DeletedAt         time.Time   `json:"deleted_at"`
	Projects          interface{} `json:"projects"`
}

func (q *Queries) ListUsersWithProjects(ctx context.Context) ([]ListUsersWithProjectsRow, error) {
	rows, err := q.db.Query(ctx, listUsersWithProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersWithProjectsRow{}
	for rows.Next() {
		var i ListUsersWithProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.HashedPassword,
			&i.IsActive,
			&i.IsEmailVerified,
			&i.LastLogin,
			&i.PasswordChangedAt,
			&i.RoleName,
			&i.Avatar,
			&i.Phone,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Projects,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeKBFromProject = `-- name: RemoveKBFromProject :exec
DELETE FROM "knowledge_base_project_mapping"
WHERE knowledge_base_id = $1 AND project_id = $2
`

type RemoveKBFromProjectParams struct {
	KnowledgeBaseID uuid.UUID `json:"knowledge_base_id"`
	ProjectID       uuid.UUID `json:"project_id"`
}

func (q *Queries) RemoveKBFromProject(ctx context.Context, arg RemoveKBFromProjectParams) error {
	_, err := q.db.Exec(ctx, removeKBFromProject, arg.KnowledgeBaseID, arg.ProjectID)
	return err
}

const removeUserFromProject = `-- name: RemoveUserFromProject :exec
DELETE FROM "user_project_mapping"
WHERE user_id = $1 AND project_id = $2
`

type RemoveUserFromProjectParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ProjectID uuid.UUID `json:"project_id"`
}

func (q *Queries) RemoveUserFromProject(ctx context.Context, arg RemoveUserFromProjectParams) error {
	_, err := q.db.Exec(ctx, removeUserFromProject, arg.UserID, arg.ProjectID)
	return err
}

const renameProject = `-- name: RenameProject :exec
UPDATE "project"
SET "name" = $2
WHERE "id" = $1
`

type RenameProjectParams struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) RenameProject(ctx context.Context, arg RenameProjectParams) error {
	_, err := q.db.Exec(ctx, renameProject, arg.ID, arg.Name)
	return err
}
