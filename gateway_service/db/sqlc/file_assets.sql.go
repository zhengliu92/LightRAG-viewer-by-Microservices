// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: file_assets.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createFileFigures = `-- name: CreateFileFigures :exec
INSERT INTO "file_figures" (owner_id, section, kb_file_id, img_path, caption, page_number)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateFileFiguresParams struct {
	OwnerID    uuid.UUID `json:"owner_id"`
	Section    string    `json:"section"`
	KbFileID   uuid.UUID `json:"kb_file_id"`
	ImgPath    string    `json:"img_path"`
	Caption    string    `json:"caption"`
	PageNumber int32     `json:"page_number"`
}

func (q *Queries) CreateFileFigures(ctx context.Context, arg CreateFileFiguresParams) error {
	_, err := q.db.Exec(ctx, createFileFigures,
		arg.OwnerID,
		arg.Section,
		arg.KbFileID,
		arg.ImgPath,
		arg.Caption,
		arg.PageNumber,
	)
	return err
}

const createFileFullText = `-- name: CreateFileFullText :exec
INSERT INTO "file_full_text" (owner_id, kb_file_id, full_text)
VALUES ($1, $2, $3)
`

type CreateFileFullTextParams struct {
	OwnerID  uuid.UUID `json:"owner_id"`
	KbFileID uuid.UUID `json:"kb_file_id"`
	FullText string    `json:"full_text"`
}

func (q *Queries) CreateFileFullText(ctx context.Context, arg CreateFileFullTextParams) error {
	_, err := q.db.Exec(ctx, createFileFullText, arg.OwnerID, arg.KbFileID, arg.FullText)
	return err
}

const createFileTables = `-- name: CreateFileTables :exec
INSERT INTO "file_tables" (owner_id, section, kb_file_id, table_html, page_number, caption)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateFileTablesParams struct {
	OwnerID    uuid.UUID `json:"owner_id"`
	Section    string    `json:"section"`
	KbFileID   uuid.UUID `json:"kb_file_id"`
	TableHtml  string    `json:"table_html"`
	PageNumber int32     `json:"page_number"`
	Caption    string    `json:"caption"`
}

func (q *Queries) CreateFileTables(ctx context.Context, arg CreateFileTablesParams) error {
	_, err := q.db.Exec(ctx, createFileTables,
		arg.OwnerID,
		arg.Section,
		arg.KbFileID,
		arg.TableHtml,
		arg.PageNumber,
		arg.Caption,
	)
	return err
}

const createFileTexts = `-- name: CreateFileTexts :exec
INSERT INTO "file_texts" (owner_id, section, kb_file_id, text, page_number)
VALUES ($1, $2, $3, $4, $5)
`

type CreateFileTextsParams struct {
	OwnerID    uuid.UUID `json:"owner_id"`
	Section    string    `json:"section"`
	KbFileID   uuid.UUID `json:"kb_file_id"`
	Text       string    `json:"text"`
	PageNumber int32     `json:"page_number"`
}

func (q *Queries) CreateFileTexts(ctx context.Context, arg CreateFileTextsParams) error {
	_, err := q.db.Exec(ctx, createFileTexts,
		arg.OwnerID,
		arg.Section,
		arg.KbFileID,
		arg.Text,
		arg.PageNumber,
	)
	return err
}

const getFileFigureByID = `-- name: GetFileFigureByID :one
SELECT id, owner_id, section, kb_file_id, img_path, caption, page_number FROM "file_figures" WHERE id = $1
`

func (q *Queries) GetFileFigureByID(ctx context.Context, id uuid.UUID) (FileFigure, error) {
	row := q.db.QueryRow(ctx, getFileFigureByID, id)
	var i FileFigure
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Section,
		&i.KbFileID,
		&i.ImgPath,
		&i.Caption,
		&i.PageNumber,
	)
	return i, err
}

const getFileFiguresByKBFileID = `-- name: GetFileFiguresByKBFileID :many
SELECT id, owner_id, section, kb_file_id, img_path, caption, page_number FROM "file_figures" WHERE kb_file_id = $1
`

func (q *Queries) GetFileFiguresByKBFileID(ctx context.Context, kbFileID uuid.UUID) ([]FileFigure, error) {
	rows, err := q.db.Query(ctx, getFileFiguresByKBFileID, kbFileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileFigure{}
	for rows.Next() {
		var i FileFigure
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Section,
			&i.KbFileID,
			&i.ImgPath,
			&i.Caption,
			&i.PageNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileFullTextByID = `-- name: GetFileFullTextByID :one
SELECT id, owner_id, kb_file_id, full_text FROM "file_full_text" WHERE id = $1
`

func (q *Queries) GetFileFullTextByID(ctx context.Context, id uuid.UUID) (FileFullText, error) {
	row := q.db.QueryRow(ctx, getFileFullTextByID, id)
	var i FileFullText
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.KbFileID,
		&i.FullText,
	)
	return i, err
}

const getFileFullTextByKBFileID = `-- name: GetFileFullTextByKBFileID :one
SELECT id, owner_id, kb_file_id, full_text FROM "file_full_text" WHERE kb_file_id = $1
`

func (q *Queries) GetFileFullTextByKBFileID(ctx context.Context, kbFileID uuid.UUID) (FileFullText, error) {
	row := q.db.QueryRow(ctx, getFileFullTextByKBFileID, kbFileID)
	var i FileFullText
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.KbFileID,
		&i.FullText,
	)
	return i, err
}

const getFileTablesByKBFileID = `-- name: GetFileTablesByKBFileID :many
SELECT id, owner_id, section, kb_file_id, table_html, caption, page_number FROM "file_tables" WHERE kb_file_id = $1
`

func (q *Queries) GetFileTablesByKBFileID(ctx context.Context, kbFileID uuid.UUID) ([]FileTable, error) {
	rows, err := q.db.Query(ctx, getFileTablesByKBFileID, kbFileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileTable{}
	for rows.Next() {
		var i FileTable
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Section,
			&i.KbFileID,
			&i.TableHtml,
			&i.Caption,
			&i.PageNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileTextsByKBFileID = `-- name: GetFileTextsByKBFileID :many
SELECT id, owner_id, kb_file_id, text, section, page_number FROM "file_texts" WHERE kb_file_id = $1
`

func (q *Queries) GetFileTextsByKBFileID(ctx context.Context, kbFileID uuid.UUID) ([]FileText, error) {
	rows, err := q.db.Query(ctx, getFileTextsByKBFileID, kbFileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileText{}
	for rows.Next() {
		var i FileText
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.KbFileID,
			&i.Text,
			&i.Section,
			&i.PageNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
