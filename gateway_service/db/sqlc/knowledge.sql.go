// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: knowledge.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addFileToKB = `-- name: AddFileToKB :exec
INSERT INTO kb_file_mapping (kb_id, kb_file_id)
VALUES ($1, $2)
`

type AddFileToKBParams struct {
	KbID     uuid.UUID `json:"kb_id"`
	KbFileID uuid.UUID `json:"kb_file_id"`
}

func (q *Queries) AddFileToKB(ctx context.Context, arg AddFileToKBParams) error {
	_, err := q.db.Exec(ctx, addFileToKB, arg.KbID, arg.KbFileID)
	return err
}

const changeKBName = `-- name: ChangeKBName :one
UPDATE "knowledge_base"
SET name = $2, updated_at = now()
WHERE id = $1
RETURNING id, name, owner_id, created_at, updated_at
`

type ChangeKBNameParams struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) ChangeKBName(ctx context.Context, arg ChangeKBNameParams) (KnowledgeBase, error) {
	row := q.db.QueryRow(ctx, changeKBName, arg.ID, arg.Name)
	var i KnowledgeBase
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createKB = `-- name: CreateKB :one
INSERT INTO "knowledge_base" (name, owner_id)
VALUES ($1, $2)
RETURNING id, name, owner_id, created_at, updated_at
`

type CreateKBParams struct {
	Name    string    `json:"name"`
	OwnerID uuid.UUID `json:"owner_id"`
}

func (q *Queries) CreateKB(ctx context.Context, arg CreateKBParams) (KnowledgeBase, error) {
	row := q.db.QueryRow(ctx, createKB, arg.Name, arg.OwnerID)
	var i KnowledgeBase
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createKBFile = `-- name: CreateKBFile :one
INSERT INTO "kb_file" (
    name,
    path,
    folder,
    size,
    owner_id
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, name, owner_id, path, folder, size, parse_status, is_parse_finished, is_parse_failed, is_assets_updated, parse_percentage, created_at, updated_at
`

type CreateKBFileParams struct {
	Name    string    `json:"name"`
	Path    string    `json:"path"`
	Folder  string    `json:"folder"`
	Size    int64     `json:"size"`
	OwnerID uuid.UUID `json:"owner_id"`
}

func (q *Queries) CreateKBFile(ctx context.Context, arg CreateKBFileParams) (KbFile, error) {
	row := q.db.QueryRow(ctx, createKBFile,
		arg.Name,
		arg.Path,
		arg.Folder,
		arg.Size,
		arg.OwnerID,
	)
	var i KbFile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Path,
		&i.Folder,
		&i.Size,
		&i.ParseStatus,
		&i.IsParseFinished,
		&i.IsParseFailed,
		&i.IsAssetsUpdated,
		&i.ParsePercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteKB = `-- name: DeleteKB :exec
DELETE FROM "knowledge_base"
WHERE id = $1
`

func (q *Queries) DeleteKB(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteKB, id)
	return err
}

const deleteKBFile = `-- name: DeleteKBFile :exec
DELETE FROM "kb_file"
WHERE id = $1
`

func (q *Queries) DeleteKBFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteKBFile, id)
	return err
}

const deleteKBFileByPathAndOwnerID = `-- name: DeleteKBFileByPathAndOwnerID :exec
DELETE FROM "kb_file"
WHERE path = $1 AND owner_id = $2
`

type DeleteKBFileByPathAndOwnerIDParams struct {
	Path    string    `json:"path"`
	OwnerID uuid.UUID `json:"owner_id"`
}

func (q *Queries) DeleteKBFileByPathAndOwnerID(ctx context.Context, arg DeleteKBFileByPathAndOwnerIDParams) error {
	_, err := q.db.Exec(ctx, deleteKBFileByPathAndOwnerID, arg.Path, arg.OwnerID)
	return err
}

const getKB = `-- name: GetKB :one
SELECT id, name, owner_id, created_at, updated_at FROM "knowledge_base"
WHERE id = $1
`

func (q *Queries) GetKB(ctx context.Context, id uuid.UUID) (KnowledgeBase, error) {
	row := q.db.QueryRow(ctx, getKB, id)
	var i KnowledgeBase
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getKBFile = `-- name: GetKBFile :one
SELECT id, name, owner_id, path, folder, size, parse_status, is_parse_finished, is_parse_failed, is_assets_updated, parse_percentage, created_at, updated_at FROM "kb_file"
WHERE id = $1
`

func (q *Queries) GetKBFile(ctx context.Context, id uuid.UUID) (KbFile, error) {
	row := q.db.QueryRow(ctx, getKBFile, id)
	var i KbFile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Path,
		&i.Folder,
		&i.Size,
		&i.ParseStatus,
		&i.IsParseFinished,
		&i.IsParseFailed,
		&i.IsAssetsUpdated,
		&i.ParsePercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getKBFileByOwnerAndPath = `-- name: GetKBFileByOwnerAndPath :one
SELECT kb_file.id, name, owner_id, path, folder, size, parse_status, is_parse_finished, is_parse_failed, is_assets_updated, parse_percentage, kb_file.created_at, updated_at, "user".id, email, username, hashed_password, is_active, is_email_verified, last_login, password_changed_at, role_name, avatar, phone, "user".created_at, deleted_at FROM "kb_file"
JOIN "user" ON "kb_file".owner_id = "user".id
WHERE "user".username = $1 AND "kb_file".path = $2
LIMIT 1
`

type GetKBFileByOwnerAndPathParams struct {
	Username string `json:"username"`
	Path     string `json:"path"`
}

type GetKBFileByOwnerAndPathRow struct {
	ID                uuid.UUID   `json:"id"`
	Name              string      `json:"name"`
	OwnerID           uuid.UUID   `json:"owner_id"`
	Path              string      `json:"path"`
	Folder            string      `json:"folder"`
	Size              int64       `json:"size"`
	ParseStatus       string      `json:"parse_status"`
	IsParseFinished   bool        `json:"is_parse_finished"`
	IsParseFailed     bool        `json:"is_parse_failed"`
	IsAssetsUpdated   bool        `json:"is_assets_updated"`
	ParsePercentage   float64     `json:"parse_percentage"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	ID_2              uuid.UUID   `json:"id_2"`
	Email             string      `json:"email"`
	Username          string      `json:"username"`
	HashedPassword    string      `json:"hashed_password"`
	IsActive          bool        `json:"is_active"`
	IsEmailVerified   bool        `json:"is_email_verified"`
	LastLogin         time.Time   `json:"last_login"`
	PasswordChangedAt time.Time   `json:"password_changed_at"`
	RoleName          string      `json:"role_name"`
	Avatar            string      `json:"avatar"`
	Phone             pgtype.Text `json:"phone"`
	CreatedAt_2       time.Time   `json:"created_at_2"`
	DeletedAt         time.Time   `json:"deleted_at"`
}

func (q *Queries) GetKBFileByOwnerAndPath(ctx context.Context, arg GetKBFileByOwnerAndPathParams) (GetKBFileByOwnerAndPathRow, error) {
	row := q.db.QueryRow(ctx, getKBFileByOwnerAndPath, arg.Username, arg.Path)
	var i GetKBFileByOwnerAndPathRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Path,
		&i.Folder,
		&i.Size,
		&i.ParseStatus,
		&i.IsParseFinished,
		&i.IsParseFailed,
		&i.IsAssetsUpdated,
		&i.ParsePercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.Email,
		&i.Username,
		&i.HashedPassword,
		&i.IsActive,
		&i.IsEmailVerified,
		&i.LastLogin,
		&i.PasswordChangedAt,
		&i.RoleName,
		&i.Avatar,
		&i.Phone,
		&i.CreatedAt_2,
		&i.DeletedAt,
	)
	return i, err
}

const getKBFileMapping = `-- name: GetKBFileMapping :one
SELECT kb_id, kb_file_id, build_status, build_percentage, is_build_finished, is_build_failed, created_at FROM "kb_file_mapping"
WHERE kb_id = $1 AND kb_file_id = $2
`

type GetKBFileMappingParams struct {
	KbID     uuid.UUID `json:"kb_id"`
	KbFileID uuid.UUID `json:"kb_file_id"`
}

func (q *Queries) GetKBFileMapping(ctx context.Context, arg GetKBFileMappingParams) (KbFileMapping, error) {
	row := q.db.QueryRow(ctx, getKBFileMapping, arg.KbID, arg.KbFileID)
	var i KbFileMapping
	err := row.Scan(
		&i.KbID,
		&i.KbFileID,
		&i.BuildStatus,
		&i.BuildPercentage,
		&i.IsBuildFinished,
		&i.IsBuildFailed,
		&i.CreatedAt,
	)
	return i, err
}

const getKBFilesByFolder = `-- name: GetKBFilesByFolder :many
SELECT id, name, owner_id, path, folder, size, parse_status, is_parse_finished, is_parse_failed, is_assets_updated, parse_percentage, created_at, updated_at FROM "kb_file"
WHERE folder = $1 AND owner_id = $2
`

type GetKBFilesByFolderParams struct {
	Folder  string    `json:"folder"`
	OwnerID uuid.UUID `json:"owner_id"`
}

func (q *Queries) GetKBFilesByFolder(ctx context.Context, arg GetKBFilesByFolderParams) ([]KbFile, error) {
	rows, err := q.db.Query(ctx, getKBFilesByFolder, arg.Folder, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KbFile{}
	for rows.Next() {
		var i KbFile
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.Path,
			&i.Folder,
			&i.Size,
			&i.ParseStatus,
			&i.IsParseFinished,
			&i.IsParseFailed,
			&i.IsAssetsUpdated,
			&i.ParsePercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKBFilesByKBID = `-- name: GetKBFilesByKBID :many
SELECT 
    kb_file.id, kb_file.name, kb_file.owner_id, kb_file.path, kb_file.folder, kb_file.size, kb_file.parse_status, kb_file.is_parse_finished, kb_file.is_parse_failed, kb_file.is_assets_updated, kb_file.parse_percentage, kb_file.created_at, kb_file.updated_at,
    COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'id', kb.id,
                'name', kb.name
            )
        ) FILTER (WHERE kb.id IS NOT NULL),
        '[]'
    ) as kbs
FROM "kb_file"
LEFT JOIN kb_file_mapping kbm ON kb_file.id = kbm.kb_file_id
LEFT JOIN knowledge_base kb ON kbm.kb_id = kb.id
WHERE kbm.kb_id = $1
GROUP BY kb_file.id
`

type GetKBFilesByKBIDRow struct {
	ID              uuid.UUID   `json:"id"`
	Name            string      `json:"name"`
	OwnerID         uuid.UUID   `json:"owner_id"`
	Path            string      `json:"path"`
	Folder          string      `json:"folder"`
	Size            int64       `json:"size"`
	ParseStatus     string      `json:"parse_status"`
	IsParseFinished bool        `json:"is_parse_finished"`
	IsParseFailed   bool        `json:"is_parse_failed"`
	IsAssetsUpdated bool        `json:"is_assets_updated"`
	ParsePercentage float64     `json:"parse_percentage"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Kbs             interface{} `json:"kbs"`
}

func (q *Queries) GetKBFilesByKBID(ctx context.Context, kbID uuid.UUID) ([]GetKBFilesByKBIDRow, error) {
	rows, err := q.db.Query(ctx, getKBFilesByKBID, kbID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetKBFilesByKBIDRow{}
	for rows.Next() {
		var i GetKBFilesByKBIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.Path,
			&i.Folder,
			&i.Size,
			&i.ParseStatus,
			&i.IsParseFinished,
			&i.IsParseFailed,
			&i.IsAssetsUpdated,
			&i.ParsePercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Kbs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKBFilesByOwner = `-- name: GetKBFilesByOwner :many
SELECT id, name, owner_id, path, folder, size, parse_status, is_parse_finished, is_parse_failed, is_assets_updated, parse_percentage, created_at, updated_at FROM "kb_file"
WHERE owner_id = $1
`

func (q *Queries) GetKBFilesByOwner(ctx context.Context, ownerID uuid.UUID) ([]KbFile, error) {
	rows, err := q.db.Query(ctx, getKBFilesByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KbFile{}
	for rows.Next() {
		var i KbFile
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.Path,
			&i.Folder,
			&i.Size,
			&i.ParseStatus,
			&i.IsParseFinished,
			&i.IsParseFailed,
			&i.IsAssetsUpdated,
			&i.ParsePercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKBFilesWithKBsByFolder = `-- name: GetKBFilesWithKBsByFolder :many
SELECT 
    kb_file.id, kb_file.name, kb_file.owner_id, kb_file.path, kb_file.folder, kb_file.size, kb_file.parse_status, kb_file.is_parse_finished, kb_file.is_parse_failed, kb_file.is_assets_updated, kb_file.parse_percentage, kb_file.created_at, kb_file.updated_at,
    COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'id', knowledge_base.id,
                'name', knowledge_base.name
            )
        ) FILTER (WHERE knowledge_base.id IS NOT NULL),
        '[]'
    ) as kbs
FROM "kb_file"
LEFT JOIN kb_file_mapping kbm ON kb_file.id = kbm.kb_file_id
LEFT JOIN knowledge_base ON kbm.kb_id = knowledge_base.id
WHERE kb_file.folder = $1 AND kb_file.owner_id = $2
GROUP BY kb_file.id
`

type GetKBFilesWithKBsByFolderParams struct {
	Folder  string    `json:"folder"`
	OwnerID uuid.UUID `json:"owner_id"`
}

type GetKBFilesWithKBsByFolderRow struct {
	ID              uuid.UUID   `json:"id"`
	Name            string      `json:"name"`
	OwnerID         uuid.UUID   `json:"owner_id"`
	Path            string      `json:"path"`
	Folder          string      `json:"folder"`
	Size            int64       `json:"size"`
	ParseStatus     string      `json:"parse_status"`
	IsParseFinished bool        `json:"is_parse_finished"`
	IsParseFailed   bool        `json:"is_parse_failed"`
	IsAssetsUpdated bool        `json:"is_assets_updated"`
	ParsePercentage float64     `json:"parse_percentage"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Kbs             interface{} `json:"kbs"`
}

func (q *Queries) GetKBFilesWithKBsByFolder(ctx context.Context, arg GetKBFilesWithKBsByFolderParams) ([]GetKBFilesWithKBsByFolderRow, error) {
	rows, err := q.db.Query(ctx, getKBFilesWithKBsByFolder, arg.Folder, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetKBFilesWithKBsByFolderRow{}
	for rows.Next() {
		var i GetKBFilesWithKBsByFolderRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.Path,
			&i.Folder,
			&i.Size,
			&i.ParseStatus,
			&i.IsParseFinished,
			&i.IsParseFailed,
			&i.IsAssetsUpdated,
			&i.ParsePercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Kbs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKBWithKBFilesByKBID = `-- name: GetKBWithKBFilesByKBID :one
SELECT 
    knowledge_base.id, knowledge_base.name, knowledge_base.owner_id, knowledge_base.created_at, knowledge_base.updated_at,
    COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'id', kb_file.id,
                'name', kb_file.name,
                'path', kb_file.path,
                'owner_id', kb_file.owner_id,
                'folder', kb_file.folder,
                'size', kb_file.size,
                'created_at', kb_file.created_at,
                'updated_at', kb_file.updated_at,
                'parse_status', kb_file.parse_status,
                'parse_percentage', kb_file.parse_percentage,
                'is_parse_finished', kb_file.is_parse_finished,
                'is_parse_failed', kb_file.is_parse_failed,
                'build_status', kbm.build_status,
                'build_percentage', kbm.build_percentage,
                'is_build_finished', kbm.is_build_finished,
                'is_build_failed', kbm.is_build_failed
            )
        ) FILTER (WHERE kb_file.id IS NOT NULL),
        '[]'
    ) as kb_files,
    COUNT(kb_file.id) as kb_file_count
FROM "knowledge_base"
LEFT JOIN kb_file_mapping kbm ON knowledge_base.id = kbm.kb_id
LEFT JOIN kb_file ON kbm.kb_file_id = kb_file.id
WHERE knowledge_base.id = $1
GROUP BY knowledge_base.id
`

type GetKBWithKBFilesByKBIDRow struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	OwnerID     uuid.UUID   `json:"owner_id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	KbFiles     interface{} `json:"kb_files"`
	KbFileCount int64       `json:"kb_file_count"`
}

func (q *Queries) GetKBWithKBFilesByKBID(ctx context.Context, id uuid.UUID) (GetKBWithKBFilesByKBIDRow, error) {
	row := q.db.QueryRow(ctx, getKBWithKBFilesByKBID, id)
	var i GetKBWithKBFilesByKBIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.KbFiles,
		&i.KbFileCount,
	)
	return i, err
}

const getNumValidKBFilesByKBID = `-- name: GetNumValidKBFilesByKBID :one
SELECT COUNT(*) FROM "kb_file_mapping"
WHERE kb_id = $1 AND is_build_failed = false AND is_build_finished = true
`

func (q *Queries) GetNumValidKBFilesByKBID(ctx context.Context, kbID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getNumValidKBFilesByKBID, kbID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRagConfigByKBID = `-- name: GetRagConfigByKBID :one
SELECT 
    rag_config.id, rag_config.owner_id, rag_config.kb_id, rag_config.embed_model, rag_config.chunk_token_size, rag_config.chunk_overlap_token_size,
    "knowledge_base".name as kb_name
FROM "rag_config"
LEFT JOIN "knowledge_base" ON "rag_config".kb_id = "knowledge_base".id
WHERE "knowledge_base".id = $1
`

type GetRagConfigByKBIDRow struct {
	ID                    uuid.UUID   `json:"id"`
	OwnerID               uuid.UUID   `json:"owner_id"`
	KbID                  uuid.UUID   `json:"kb_id"`
	EmbedModel            string      `json:"embed_model"`
	ChunkTokenSize        int32       `json:"chunk_token_size"`
	ChunkOverlapTokenSize int32       `json:"chunk_overlap_token_size"`
	KbName                pgtype.Text `json:"kb_name"`
}

func (q *Queries) GetRagConfigByKBID(ctx context.Context, id uuid.UUID) (GetRagConfigByKBIDRow, error) {
	row := q.db.QueryRow(ctx, getRagConfigByKBID, id)
	var i GetRagConfigByKBIDRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.KbID,
		&i.EmbedModel,
		&i.ChunkTokenSize,
		&i.ChunkOverlapTokenSize,
		&i.KbName,
	)
	return i, err
}

const getUserKBs = `-- name: GetUserKBs :many
SELECT "knowledge_base"."id",
        "knowledge_base"."name",
        "knowledge_base"."owner_id",
        "knowledge_base"."created_at",
        "knowledge_base"."updated_at",
        COUNT(kb_file_mapping.kb_file_id) AS kb_file_count,
        SUM(CASE WHEN kb_file_mapping.is_build_finished = true AND kb_file_mapping.is_build_failed = false THEN 1 ELSE 0 END) AS kb_file_build_finished_count
FROM "knowledge_base"
LEFT JOIN kb_file_mapping ON knowledge_base.id = kb_file_mapping.kb_id
LEFT JOIN knowledge_base_project_mapping ON knowledge_base.id = knowledge_base_project_mapping.knowledge_base_id
WHERE knowledge_base.owner_id = $1
AND knowledge_base_project_mapping.project_id IS NULL
GROUP BY knowledge_base.id
ORDER BY kb_file_count DESC
`

type GetUserKBsRow struct {
	ID                       uuid.UUID `json:"id"`
	Name                     string    `json:"name"`
	OwnerID                  uuid.UUID `json:"owner_id"`
	CreatedAt                time.Time `json:"created_at"`
	UpdatedAt                time.Time `json:"updated_at"`
	KbFileCount              int64     `json:"kb_file_count"`
	KbFileBuildFinishedCount int64     `json:"kb_file_build_finished_count"`
}

func (q *Queries) GetUserKBs(ctx context.Context, ownerID uuid.UUID) ([]GetUserKBsRow, error) {
	rows, err := q.db.Query(ctx, getUserKBs, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserKBsRow{}
	for rows.Next() {
		var i GetUserKBsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.KbFileCount,
			&i.KbFileBuildFinishedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFileFromKB = `-- name: RemoveFileFromKB :exec
DELETE FROM kb_file_mapping
WHERE kb_id = $1 AND kb_file_id = $2
`

type RemoveFileFromKBParams struct {
	KbID     uuid.UUID `json:"kb_id"`
	KbFileID uuid.UUID `json:"kb_file_id"`
}

func (q *Queries) RemoveFileFromKB(ctx context.Context, arg RemoveFileFromKBParams) error {
	_, err := q.db.Exec(ctx, removeFileFromKB, arg.KbID, arg.KbFileID)
	return err
}

const updateKBFile = `-- name: UpdateKBFile :one
UPDATE "kb_file"
SET
  name = COALESCE($1, name),
  path = COALESCE($2, path),
  folder = COALESCE($3, folder), 
  owner_id = COALESCE($4, owner_id),
  parse_status = COALESCE($5, parse_status),
  parse_percentage = COALESCE($6, parse_percentage),
  is_parse_finished = COALESCE($7, is_parse_finished),
  is_assets_updated = COALESCE($8, is_assets_updated),
  is_parse_failed = COALESCE($9, is_parse_failed),
  updated_at = now()
WHERE id = $10
RETURNING id, name, owner_id, path, folder, size, parse_status, is_parse_finished, is_parse_failed, is_assets_updated, parse_percentage, created_at, updated_at
`

type UpdateKBFileParams struct {
	Name            pgtype.Text   `json:"name"`
	Path            pgtype.Text   `json:"path"`
	Folder          pgtype.Text   `json:"folder"`
	OwnerID         pgtype.UUID   `json:"owner_id"`
	ParseStatus     pgtype.Text   `json:"parse_status"`
	ParsePercentage pgtype.Float8 `json:"parse_percentage"`
	IsParseFinished pgtype.Bool   `json:"is_parse_finished"`
	IsAssetsUpdated pgtype.Bool   `json:"is_assets_updated"`
	IsParseFailed   pgtype.Bool   `json:"is_parse_failed"`
	ID              uuid.UUID     `json:"id"`
}

func (q *Queries) UpdateKBFile(ctx context.Context, arg UpdateKBFileParams) (KbFile, error) {
	row := q.db.QueryRow(ctx, updateKBFile,
		arg.Name,
		arg.Path,
		arg.Folder,
		arg.OwnerID,
		arg.ParseStatus,
		arg.ParsePercentage,
		arg.IsParseFinished,
		arg.IsAssetsUpdated,
		arg.IsParseFailed,
		arg.ID,
	)
	var i KbFile
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.Path,
		&i.Folder,
		&i.Size,
		&i.ParseStatus,
		&i.IsParseFinished,
		&i.IsParseFailed,
		&i.IsAssetsUpdated,
		&i.ParsePercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateKBFileMapping = `-- name: UpdateKBFileMapping :one
UPDATE "kb_file_mapping"
SET 
    build_status = COALESCE($1, build_status),
    build_percentage = COALESCE($2, build_percentage),
    is_build_finished = COALESCE($3, is_build_finished),
    is_build_failed = COALESCE($4, is_build_failed)
WHERE kb_id = $5 AND kb_file_id = $6
RETURNING kb_id, kb_file_id, build_status, build_percentage, is_build_finished, is_build_failed, created_at
`

type UpdateKBFileMappingParams struct {
	BuildStatus     pgtype.Text   `json:"build_status"`
	BuildPercentage pgtype.Float8 `json:"build_percentage"`
	IsBuildFinished pgtype.Bool   `json:"is_build_finished"`
	IsBuildFailed   pgtype.Bool   `json:"is_build_failed"`
	KbID            uuid.UUID     `json:"kb_id"`
	KbFileID        uuid.UUID     `json:"kb_file_id"`
}

func (q *Queries) UpdateKBFileMapping(ctx context.Context, arg UpdateKBFileMappingParams) (KbFileMapping, error) {
	row := q.db.QueryRow(ctx, updateKBFileMapping,
		arg.BuildStatus,
		arg.BuildPercentage,
		arg.IsBuildFinished,
		arg.IsBuildFailed,
		arg.KbID,
		arg.KbFileID,
	)
	var i KbFileMapping
	err := row.Scan(
		&i.KbID,
		&i.KbFileID,
		&i.BuildStatus,
		&i.BuildPercentage,
		&i.IsBuildFinished,
		&i.IsBuildFailed,
		&i.CreatedAt,
	)
	return i, err
}

const upsertRagConfig = `-- name: UpsertRagConfig :exec
INSERT INTO "rag_config" (owner_id, kb_id, chunk_token_size, chunk_overlap_token_size, embed_model)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (owner_id, kb_id) DO UPDATE SET chunk_token_size = $3, chunk_overlap_token_size = $4, embed_model = $5
`

type UpsertRagConfigParams struct {
	OwnerID               uuid.UUID `json:"owner_id"`
	KbID                  uuid.UUID `json:"kb_id"`
	ChunkTokenSize        int32     `json:"chunk_token_size"`
	ChunkOverlapTokenSize int32     `json:"chunk_overlap_token_size"`
	EmbedModel            string    `json:"embed_model"`
}

func (q *Queries) UpsertRagConfig(ctx context.Context, arg UpsertRagConfigParams) error {
	_, err := q.db.Exec(ctx, upsertRagConfig,
		arg.OwnerID,
		arg.KbID,
		arg.ChunkTokenSize,
		arg.ChunkOverlapTokenSize,
		arg.EmbedModel,
	)
	return err
}
